diff --git a/kern/env.c b/kern/env.c
index 0564b2b..f681f1c 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -48,13 +48,11 @@ static struct Env *env_free_list;
 int
 envid2env(envid_t envid, struct Env **env_store, bool need_check_perm) {
     struct Env *env;
-
     /* If envid is zero, return the current environment. */
     if (!envid) {
         *env_store = curenv;
         return 0;
     }
-
     /* Look up the Env structure via the index part of the envid,
      * then check the env_id field in that struct Env
      * to ensure that the envid is not stale
@@ -65,7 +63,6 @@ envid2env(envid_t envid, struct Env **env_store, bool need_check_perm) {
         *env_store = NULL;
         return -E_BAD_ENV;
     }
-
     /* Check that the calling environment has legitimate permission
      * to manipulate the specified environment.
      * If checkperm is set, the specified environment
@@ -95,15 +92,14 @@ env_init(void) {
     // LAB 8: Your code here
 
     envs = (struct Env *)kzalloc_region(sizeof(* envs) * NENV);
-    memset(envs, 0, sizeof(*envs) * NENV);
-    cprintf("envs - %p\n", (void*)envs);
+    //memset(envs, 0, sizeof(*envs) * NENV);
+    //cprintf("envs - %p\n", (void*)envs);
 
     /* Map envs to UENVS read-only,
      * but user-accessible (with PROT_USER_ set) */
     // LAB 8: Your code here
-
-    if (map_region(&kspace, UENVS, NULL, PADDR(envs), UENVS_SIZE, PROT_R | PROT_USER_))
-        panic("Cannot map physical region at %p of size %lld", (void *)PADDR(envs), UENVS_SIZE);
+    if (map_region(current_space, UENVS, &kspace, (uintptr_t)envs, UENVS_SIZE, PROT_R | PROT_USER_))
+       panic("Cannot map physical region at %p of size %lld", (void *)envs, UENVS_SIZE);
     /* Set up envs array */
 
     // LAB 3: Your code here
@@ -157,7 +153,6 @@ env_alloc(struct Env **newenv_store, envid_t parent_id, enum EnvType type) {
      * of a prior environment inhabiting this Env structure
      * from "leaking" into our new environment */
     memset(&env->env_tf, 0, sizeof(env->env_tf));
-
     /* Set up appropriate initial values for the segment registers.
      * GD_UD is the user data (KD - kernel data) segment selector in the GDT, and
      * GD_UT is the user text (KT - kernel text) segment selector (see inc/memlayout.h).
@@ -293,7 +288,7 @@ static int
 load_icode(struct Env *env, uint8_t *binary, size_t size) {
     // LAB 3: Your code here
     // /LoaderPkg/Include/Elf64.h
-    cprintf("lox\n");
+
     struct Elf *elf = (struct Elf*)binary;
     struct Proghdr *ph = (struct Proghdr*)(binary + elf->e_phoff);
     if (elf->e_magic != ELF_MAGIC) {
@@ -301,9 +296,9 @@ load_icode(struct Env *env, uint8_t *binary, size_t size) {
      return -E_INVALID_EXE;
     }
 
-    lcr3(PADDR(env->address_space.pml4));
+    //dump_page_table(env->address_space.pml4);
+    switch_address_space(&env->address_space);
 
-    cprintf("lox\n");
     for (size_t i = 0; i < elf->e_phnum; i++) {
      if (ph[i].p_type == ELF_PROG_LOAD) {
       void *src = binary + ph[i].p_offset;
@@ -313,32 +308,32 @@ load_icode(struct Env *env, uint8_t *binary, size_t size) {
       size_t safety_filesize = memsz - filesz;
       size_t filesz2 = MIN(ph[i].p_filesz, memsz);
 
-      map_region(&env->address_space, (uintptr_t)dst, NULL, 0, memsz, PROT_R | PROT_W); //maybe + | PROT_USER_
-
       if (safety_filesize < 0) {
        cprintf("ph->p_filesz > ph->p_memsz\n");
        return -E_INVALID_EXE;
       } else {
-       cprintf("lox1\n");
-       cprintf("0x%08lX\n", ph[i].p_va);
-       cprintf("%p\n", src);
-       cprintf("%lu\n", filesz2);
+        map_region(&env->address_space, ROUNDDOWN((uintptr_t)dst, PAGE_SIZE), NULL, 0, ROUNDUP((uintptr_t)dst + memsz, PAGE_SIZE) - ROUNDDOWN((uintptr_t)dst, PAGE_SIZE), PROT_RWX | PROT_USER_ | ALLOC_ZERO); 
+        //cprintf("%d\n", res);
+        //region_maxref(&env->address_space, (uintptr_t)dst, memsz);
+       //cprintf("0x%08lX\n", ph[i].p_va);
+       //cprintf("%p\n", src);
+       //cprintf("%lu\n", filesz2);
        memcpy(dst, src, filesz2);
-       cprintf("lox2.1\n");
        memset((void*)ph[i].p_va + filesz2, 0, safety_filesize);
-       cprintf("lox2.2\n");
       }
      }
     }
-    cprintf("lox2.3\n");
+    switch_address_space(&kspace);
     env->env_tf.tf_rip = elf->e_entry;
     uintptr_t image_start = 0;
     uintptr_t image_end = 0;
     bind_functions(env, binary, size, image_start, image_end);
-    return 0;
  
     // LAB 8: Your code here
-    //return 0;
+    map_region(&env->address_space, USER_STACK_TOP - USER_STACK_SIZE, NULL, 0, USER_STACK_SIZE, PROT_RWX | PROT_USER_ | ALLOC_ZERO); 
+    //cprintf("%d\n", res);
+
+    return 0;
 }
 
 /* Allocates a new env with env_alloc, loads the named elf
@@ -355,8 +350,11 @@ env_create(uint8_t *binary, size_t size, enum EnvType type) {
     if (env_alloc(&new_env, 0, type) < 0) {
      panic("No free environment\n");
     }
-
+    ///curenv->binary = binary;
+    //cprintf("%p\n", (void*)curenv);
+    new_env->binary = binary;
     load_icode(new_env, binary, size);
+
 }
 
 
@@ -406,6 +404,7 @@ env_destroy(struct Env *env) {
     if (env->env_tf.tf_trapno == T_PGFLT) {
         assert(current_space);
         assert(!in_page_fault);
+        cprintf("in_page_fault\n");
         in_page_fault = 0;
     }
 }
diff --git a/kern/kdebug.c b/kern/kdebug.c
index e22662e..66c8cd3 100644
--- a/kern/kdebug.c
+++ b/kern/kdebug.c
@@ -55,6 +55,18 @@ load_user_dwarf_info(struct Dwarf_Addrs *addrs) {
 
     /* Load debug sections from curenv->binary elf image */
     // LAB 8: Your code here
+    struct Elf* user_elf = (struct Elf*)(binary);
+    struct Secthdr* sect_hdr = (struct Secthdr*)(binary + user_elf->e_shoff);
+    const char* sh_str = (char *)(binary + sect_hdr[user_elf->e_shstrndx].sh_offset);
+    for (size_t i = 0; i < user_elf->e_shnum; ++i) {
+        for (size_t j = 0; j < sizeof(sections) / sizeof(*sections); ++j) {
+            if (!strcmp(&sh_str[sect_hdr[i].sh_name], sections[j].name)) {
+                *sections[j].start = binary + sect_hdr[i].sh_offset;
+                *sections[j].end = binary + sect_hdr[i].sh_offset + sect_hdr[i].sh_size;
+            }
+        }
+   }
+
 }
 
 #define UNKNOWN       "<unknown>"
@@ -82,6 +94,8 @@ debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info) {
     * Make sure that you fully understand why it is necessary. */
     // LAB 8: Your code here
 
+    struct AddressSpace* old_current = switch_address_space(&curenv->address_space);
+
     /* Load dwarf section pointers from either
      * currently running program binary or use
      * kernel debug info provided by bootloader
@@ -90,7 +104,13 @@ debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info) {
     // LAB 8: Your code here:
 
     struct Dwarf_Addrs addrs;
-    load_kernel_dwarf_info(&addrs);
+    if (addr < MAX_USER_READABLE) {
+        load_user_dwarf_info(&addrs);
+    } else {
+        load_kernel_dwarf_info(&addrs);
+    }
+
+    switch_address_space(old_current);
 
     Dwarf_Off offset = 0, line_offset = 0;
     int res = info_by_address(&addrs, addr, &offset);
diff --git a/kern/pmap.c b/kern/pmap.c
index 4d1e103..ce5cede 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -654,6 +654,27 @@ dump_page_table(pte_t *pml4) {
     cprintf("Page table:\n");
     (void)addr;
     // LAB 7: Your code here
+    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; ++i) {
+        if (pml4[i] == 0) continue;
+        dump_entry(pml4[i], 512 * GB, true);
+        pdpe_t* pdp = KADDR(PTE_ADDR(pml4[i]));
+        for (size_t j = 0; j < PDP_ENTRY_COUNT; ++j) {
+            if (pdp[j] == 0) continue;
+            dump_entry(pdp[j], 1 * GB, true);
+            if (pdp[j] & PTE_PS) continue;
+            pde_t* pd = KADDR(PTE_ADDR(pdp[j]));
+            for (size_t k = 0; k < PD_ENTRY_COUNT; ++k) {
+                if (pd[k] == 0) continue;
+                dump_entry(pd[k], 2 * MB, true);
+                if (pd[k] & PTE_PS) continue;
+                pte_t* pt = KADDR(PTE_ADDR(pd[k]));
+                for (size_t l = 0; l < PT_ENTRY_COUNT; ++l) {
+                    if (pt[l] == 0) continue;
+                    dump_entry(pt[l], 4 * KB, true);
+                }
+            }
+        }
+    }
 }
 
 inline static int
@@ -751,12 +772,14 @@ memcpy_page(struct AddressSpace *dst, uintptr_t va, struct Page *page) {
     assert(dst);
     // LAB 7: Your code here
     struct AddressSpace* old_current = switch_address_space(dst);
-    struct Page* virtual_page = page_lookup_virtual(dst->root, va, page->class, LOOKUP_ALLOC); // ищется виртуальная страница и выделаяется по заданному адресу, там же 
+    //struct Page* virtual_page = page_lookup_virtual(dst->root, va, page->class, LOOKUP_ALLOC); // ищется виртуальная страница и выделаяется по заданному адресу, там же 
     // выделяется физическая страница
     set_wp(false);
+    //cprintf("here_special\n");
+    nosan_memcpy((void*)va, KADDR(page2pa(page)), CLASS_SIZE(page->class));
     //nosan_memcpy(KADDR(page2pa(page)), KADDR(page2pa(virtual_page->phy)), CLASS_SIZE(page->class)); // копируем контент физ  страницу page в выделенную page_lookup_virtual 
     //физ страницу соотв. виртуальной странице
-    nosan_memcpy(KADDR(page2pa(virtual_page->phy)), KADDR(page2pa(page)), CLASS_SIZE(page->class));
+    //nosan_memcpy(KADDR(page2pa(virtual_page->phy)), KADDR(page2pa(page)), CLASS_SIZE(page->class));
     set_wp(true);
     switch_address_space(old_current);
 }
@@ -1394,7 +1417,11 @@ do_map_region_one_page(struct AddressSpace *dspace, uintptr_t dst, struct Addres
 
 int
 map_region(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspace, uintptr_t src, uintptr_t size, int flags) {
-    if (src & CLASS_MASK(0) || (!sspace && !(flags & (ALLOC_ZERO | ALLOC_ONE)))) return -E_INVAL;
+    if (src & CLASS_MASK(0) || (!sspace && !(flags & (ALLOC_ZERO | ALLOC_ONE)))) {
+        cprintf("%lld\n", src & CLASS_MASK(0));
+        cprintf("%d\n", !(flags & (ALLOC_ZERO | ALLOC_ONE)));
+        return -E_INVAL;
+    }
     if (dst & CLASS_MASK(0) || !dspace) return -E_INVAL;
     if (size & CLASS_MASK(0) || !size) return -E_INVAL;
 
@@ -1421,7 +1448,6 @@ map_region(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspa
             src += CLASS_SIZE(class);
         }
     }
-
     return 0;
 }
 
@@ -1481,17 +1507,26 @@ init_address_space(struct AddressSpace *space) {
     /* Allocte page table with alloc_pt into space->cr3
      * (remember to clean flag bits of result with PTE_ADDR) */
     // LAB 8: Your code here
+    pte_t pte = 0;
+    int res = alloc_pt(&pte);
+    if (res != 0) {
+        return res;
+    }
+    pte = PTE_ADDR(pte);
+    space->cr3 = pte;
 
     /* put its kernel virtual address to space->pml4 */
     // LAB 8: Your code here
-
+    space->pml4 = KADDR(space->cr3);
     // Allocate virtual tree root node
     // of type INTERMEDIATE_NODE with alloc_rescriptor() of type
     // LAB 8: Your code here
-
+    space->root = alloc_descriptor(INTERMEDIATE_NODE);
     /* Initialize UVPT */
     // LAB 8: Your code here
 
+    space->pml4[PML4_INDEX(UVPT)] = space->cr3 | PTE_P | PTE_U;
+
     /* Why this call is required here and what does it do? */
     propagate_one_pml4(space, &kspace);
     return 0;
@@ -1753,7 +1788,7 @@ init_memory(void) {
     // NOTE: You need to check if map_physical_region returned 0 everywhere! (and panic otherwise)
     // Map [0, max_memory_map_addr] to [KERN_BASE_ADDR, KERN_BASE_ADDR + max_memory_map_addr] as RW- + ALLOC_WEAK
 
-    if (map_physical_region(&kspace, KERN_BASE_ADDR, 0, max_memory_map_addr, PROT_R | PROT_W | ALLOC_WEAK | PROT_X) < 0) {
+    if (map_physical_region(&kspace, KERN_BASE_ADDR, 0, max_memory_map_addr, PROT_R | PROT_W | ALLOC_WEAK) < 0) {
         panic("Cannot map physical region at %p of size %zd", (void *)0, max_memory_map_addr);
     }
 
@@ -1776,11 +1811,11 @@ init_memory(void) {
     // Map [PADDR(bootstack), PADDR(bootstack) + KERN_STACK_SIZE] to [KERN_STACK_TOP - KERN_STACK_SIZE, KERN_STACK_TOP] as RW-
     // Map [PADDR(pfstack), PADDR(pfstack) + KERN_PF_STACK_SIZE] to [KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE, KERN_PF_STACK_TOP] as RW-
 
-    if (map_physical_region(&kspace, KERN_STACK_TOP - KERN_STACK_SIZE, PADDR(bootstack), KERN_STACK_SIZE, PROT_R | PROT_W | PROT_X) < 0) {
+    if (map_physical_region(&kspace, KERN_STACK_TOP - KERN_STACK_SIZE, PADDR(bootstack), KERN_STACK_SIZE, PROT_R | PROT_W) < 0) {
         panic("Cannot map physical region at %p of size %lld", (void *)PADDR(bootstack), KERN_STACK_SIZE);
     }
 
-    if (map_physical_region(&kspace, KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE, PADDR(pfstack), KERN_PF_STACK_SIZE, PROT_R | PROT_W | PROT_X) < 0) {
+    if (map_physical_region(&kspace, KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE, PADDR(pfstack), KERN_PF_STACK_SIZE, PROT_R | PROT_W) < 0) {
         panic("Cannot map physical region at %p of size %lld", (void *)PADDR(pfstack), KERN_PF_STACK_SIZE);
     }
 
@@ -1795,7 +1830,7 @@ init_memory(void) {
             // LAB 7: Your code here
             // Map [mstart->PhysicalStart, mstart->PhysicalStart+mstart->NumberOfPages*PAGE_SIZE] to
             //     [mstart->VirtualStart, mstart->VirtualStart+mstart->NumberOfPages*PAGE_SIZE] as RW-
-            if (map_physical_region(&kspace, mstart->VirtualStart, mstart->PhysicalStart, mstart->NumberOfPages*PAGE_SIZE, PROT_R | PROT_W | PROT_X) < 0) {
+            if (map_physical_region(&kspace, mstart->VirtualStart, mstart->PhysicalStart, mstart->NumberOfPages*PAGE_SIZE, PROT_R | PROT_W) < 0) {
                 panic("Cannot map physical region at %p of size %llu", (void *)mstart->PhysicalStart, mstart->NumberOfPages * PAGE_SIZE);
             }
         }
@@ -1864,26 +1899,22 @@ init_memory(void) {
     // Map [X86ADDR(KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE), KERN_PF_STACK_TOP] to
     //     [PADDR(pfstack), PADDR(pfstacktop)] as RW-
 
-    //ВОТ ЭТОТ МАППИНГ НЕ ПАШЕТ
     uintptr_t p_start_map = 0, _size = 0;
-    cprintf("some1");
     
     p_start_map = uefi_lp->FrameBufferBase;
-    cprintf("0x%08lX\n", p_start_map);
     _size = uefi_lp->FrameBufferSize;
-    cprintf("0x%08lX\n", _size);
-    if (map_physical_region(&kspace, FRAMEBUFFER, p_start_map, _size, PROT_R | PROT_W | PROT_WC | PROT_X) < 0) {
+
+    if (map_physical_region(&kspace, FRAMEBUFFER, p_start_map, _size, PROT_R | PROT_W | PROT_WC) < 0) {
         panic("Cannot map physical region at %p of size %zd", (void *)p_start_map, _size);
     }
-    cprintf("some2");
 
     p_start_map = 0;
+
     _size = MIN(MAX_LOW_ADDR_KERN_SIZE, max_memory_map_addr);
-    if (map_physical_region(&kspace, X86ADDR(KERN_BASE_ADDR), p_start_map, _size, PROT_R | PROT_W | ALLOC_WEAK | PROT_X) < 0) {
+    if (map_physical_region(&kspace, X86ADDR(KERN_BASE_ADDR), p_start_map, _size, PROT_R | PROT_W | ALLOC_WEAK) < 0) {
         panic("Cannot map physical region at %p of size %zd", (void *)p_start_map, _size);
     }
 
-    //cprintf("next\n");
     p_start_map = PADDR(__text_start);
     _size = ROUNDUP(X86ADDR((uintptr_t)__text_end), CLASS_SIZE(0)) - X86ADDR((uintptr_t)__text_start);
     if (map_physical_region(&kspace, X86ADDR((uintptr_t)__text_start), p_start_map, _size, PROT_R | PROT_X) < 0) {
@@ -1892,14 +1923,13 @@ init_memory(void) {
 
     p_start_map = PADDR(bootstack);
     _size = KERN_STACK_SIZE;
-    if (map_physical_region(&kspace, X86ADDR(KERN_STACK_TOP - KERN_STACK_SIZE), p_start_map, _size, PROT_R | PROT_W | PROT_X) < 0) {
+    if (map_physical_region(&kspace, X86ADDR(KERN_STACK_TOP - KERN_STACK_SIZE), p_start_map, _size, PROT_R | PROT_W) < 0) {
         panic("Cannot map physical region at %p of size %zd", (void *)p_start_map, _size);
     }
     
-
     p_start_map = PADDR(pfstack);
     _size = KERN_PF_STACK_SIZE;
-    if (map_physical_region(&kspace, X86ADDR(KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE), p_start_map, _size, PROT_R | PROT_W | PROT_X) < 0) {
+    if (map_physical_region(&kspace, X86ADDR(KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE), p_start_map, _size, PROT_R | PROT_W) < 0) {
         panic("Cannot map physical region at %p of size %zd", (void *)p_start_map, _size);
     }  
 
diff --git a/kern/sched.c b/kern/sched.c
index 3316f32..0c5885f 100644
--- a/kern/sched.c
+++ b/kern/sched.c
@@ -38,8 +38,10 @@ sched_yield(void) {
 
     if (index >= 0) {
         env_run(&envs[index]);
+        cprintf("run env1\n");
     } else if (curenv && curenv->env_status == ENV_RUNNING) {
         env_run(curenv);
+        cprintf("run curenv\n");
     }
 
     cprintf("Halt\n"); 
diff --git a/kern/syscall.c b/kern/syscall.c
index 58f015e..9fe7bc0 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -20,9 +20,14 @@
 static int
 sys_cputs(const char *s, size_t len) {
     // LAB 8: Your code here
-
+    //for (size_t i = 0; i < len; ++i) {
+      //  cputchar(s[i]);
+    //}
+    user_mem_assert(curenv, s, len, PROT_R);
+    cprintf("%.*s", (int)len, s);
     /* Check that the user has permission to read memory [s, s+len).
     * Destroy the environment if not. */
+    
 
     return 0;
 }
@@ -32,8 +37,7 @@ sys_cputs(const char *s, size_t len) {
 static int
 sys_cgetc(void) {
     // LAB 8: Your code here
-
-    return 0;
+    return cons_getc();
 }
 
 /* Returns the current environment's envid. */
@@ -41,7 +45,7 @@ static envid_t
 sys_getenvid(void) {
     // LAB 8: Your code here
 
-    return 0;
+    return curenv->env_id;
 }
 
 /* Destroy a given environment (possibly the currently running environment).
@@ -53,9 +57,14 @@ sys_getenvid(void) {
 static int
 sys_env_destroy(envid_t envid) {
     // LAB 8: Your code here.
+    int res = 0;
+    struct Env* env;
+    res = envid2env(envid, &env, 1);
+    if (res < 0) {
+        return -E_BAD_ENV;
+    }
 
-
-#if 0 /* TIP: Use this snippet to log required for passing grade tests info */
+#if 1 /* TIP: Use this snippet to log required for passing grade tests info */
     if (trace_envs) {
         cprintf(env == curenv ?
                         "[%08x] exiting gracefully\n" :
@@ -64,6 +73,8 @@ sys_env_destroy(envid_t envid) {
     }
 #endif
 
+    env_destroy(env);
+
     return 0;
 }
 
@@ -74,5 +85,14 @@ syscall(uintptr_t syscallno, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t
      * Return any appropriate return value. */
 
     // LAB 8: Your code here
+    if (syscallno == SYS_cputs) {
+        return sys_cputs((const char *)a1, (size_t)a2);
+    } else if (syscallno == SYS_cgetc) {
+        return sys_cgetc();
+    } else if (syscallno == SYS_getenvid) {
+        return sys_getenvid();
+    } else if (syscallno == SYS_env_destroy) {
+        return sys_env_destroy((envid_t)a1);
+    }
     return -E_NO_SYS;
 }
diff --git a/kern/traceopt.h b/kern/traceopt.h
index 8ab68d2..947759e 100644
--- a/kern/traceopt.h
+++ b/kern/traceopt.h
@@ -14,7 +14,7 @@
 #ifndef trace_memory
 /* TIP: set this to (!!curenv)
  *      to enable logging after initiallization */
-#define trace_memory 1
+#define trace_memory 0
 #endif
 
 #ifndef trace_memory_more
diff --git a/kern/trap.c b/kern/trap.c
index 3256133..bdd406d 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -275,6 +275,7 @@ trap_dispatch(struct Trapframe *tf) {
         return;
     case T_BRKPT:
         // LAB 8: Your code here
+        monitor(tf);
         return;
     case IRQ_OFFSET + IRQ_SPURIOUS:
         /* Handle spurious interrupts
diff --git a/lib/libmain.c b/lib/libmain.c
index 369690b..11e5b21 100644
--- a/lib/libmain.c
+++ b/lib/libmain.c
@@ -23,6 +23,9 @@ libmain(int argc, char **argv) {
 
     /* Set thisenv to point at our Env structure in envs[]. */
     // LAB 8: Your code here
+    //
+
+    thisenv = &envs[ENVX(sys_getenvid())];
 
     /* Save the name of the program so that panic() can use it */
     if (argc > 0) binaryname = argv[0];
diff --git a/llvm/asan/asan_platform.ujos.c b/llvm/asan/asan_platform.ujos.c
index 6205cd3..9af6408 100644
--- a/llvm/asan/asan_platform.ujos.c
+++ b/llvm/asan/asan_platform.ujos.c
@@ -98,15 +98,23 @@ platform_asan_init() {
 
     /* Unpoison the vital areas:
      *(fill with 0's using platform_asan_unpoison())*/
+    platform_asan_unpoison(&__text_start, &__text_end - &__text_start);
+    platform_asan_unpoison(&__data_start, &__data_end - &__data_start);
+    platform_asan_unpoison(&__rodata_start, &__rodata_end - &__rodata_start);
+    platform_asan_unpoison(&__bss_start, &__bss_end - &__bss_start);
 
     /* 1. Program segments (text, data, rodata, bss) */
     // LAB 8: Your code here
 
     /* 2. Stacks (USER_EXCEPTION_STACK_TOP, USER_STACK_TOP) */
     // LAB 8: Your code here
+    platform_asan_unpoison((void *)(USER_EXCEPTION_STACK_TOP - USER_EXCEPTION_STACK_SIZE), USER_EXCEPTION_STACK_SIZE);
+    platform_asan_unpoison((void *)(USER_STACK_TOP - USER_STACK_SIZE), USER_STACK_SIZE);
 
     /* 3. Kernel exposed info (UENVS, UVSYS (only for lab 12)) */
     // LAB 8: Your code here
+    platform_asan_unpoison((void *)UENVS, UENVS_SIZE);
+
 
 #if LAB >= 12
     platform_asan_unpoison((uptr)UVSYS, NVSYSCALLS * sizeof(int));
diff --git a/my.diff b/my.diff
index 3a73840..f14c7a4 100644
--- a/my.diff
+++ b/my.diff
@@ -1,158 +0,0 @@
-diff --git a/kern/env.c b/kern/env.c
-index 61cee72..0564b2b 100644
---- a/kern/env.c
-+++ b/kern/env.c
-@@ -94,10 +94,16 @@ env_init(void) {
-      * (don't forget about rounding) */
-     // LAB 8: Your code here
- 
-+    envs = (struct Env *)kzalloc_region(sizeof(* envs) * NENV);
-+    memset(envs, 0, sizeof(*envs) * NENV);
-+    cprintf("envs - %p\n", (void*)envs);
-+
-     /* Map envs to UENVS read-only,
-      * but user-accessible (with PROT_USER_ set) */
-     // LAB 8: Your code here
- 
-+    if (map_region(&kspace, UENVS, NULL, PADDR(envs), UENVS_SIZE, PROT_R | PROT_USER_))
-+        panic("Cannot map physical region at %p of size %lld", (void *)PADDR(envs), UENVS_SIZE);
-     /* Set up envs array */
- 
-     // LAB 3: Your code here
-@@ -294,6 +300,9 @@ load_icode(struct Env *env, uint8_t *binary, size_t size) {
-      cprintf("Unexpected ELF format\n");
-      return -E_INVALID_EXE;
-     }
-+
-+    lcr3(PADDR(env->address_space.pml4));
-+
-     cprintf("lox\n");
-     for (size_t i = 0; i < elf->e_phnum; i++) {
-      if (ph[i].p_type == ELF_PROG_LOAD) {
-@@ -303,6 +312,9 @@ load_icode(struct Env *env, uint8_t *binary, size_t size) {
-       size_t memsz = ph[i].p_memsz;
-       size_t safety_filesize = memsz - filesz;
-       size_t filesz2 = MIN(ph[i].p_filesz, memsz);
-+
-+      map_region(&env->address_space, (uintptr_t)dst, NULL, 0, memsz, PROT_R | PROT_W); //maybe + | PROT_USER_
-+
-       if (safety_filesize < 0) {
-        cprintf("ph->p_filesz > ph->p_memsz\n");
-        return -E_INVALID_EXE;
-@@ -391,6 +403,11 @@ env_destroy(struct Env *env) {
-     }
- 
-     // LAB 8: Your code here (set in_page_fault = 0)
-+    if (env->env_tf.tf_trapno == T_PGFLT) {
-+        assert(current_space);
-+        assert(!in_page_fault);
-+        in_page_fault = 0;
-+    }
- }
- 
- #ifdef CONFIG_KSPACE
-@@ -486,6 +503,7 @@ env_run(struct Env *env) {
-     curenv = env;
-     curenv->env_status = ENV_RUNNING;
-     curenv->env_runs += 1;
-+    switch_address_space(&(curenv->address_space));
-     env_pop_tf(&curenv->env_tf);
- 
-     while(1) {}
-diff --git a/kern/init.c b/kern/init.c
-index fc441fa..abe7f44 100644
---- a/kern/init.c
-+++ b/kern/init.c
-@@ -157,6 +157,7 @@ i386_init(void) {
- 
-     /* Choose the timer used for scheduling: hpet or pit */
-     timers_schedule("hpet0");
-+    clock_idt_init();
- 
- #ifdef CONFIG_KSPACE
-     /* Touch all you want */
-diff --git a/kern/kdebug.c b/kern/kdebug.c
-index 8d1ebe9..e22662e 100644
---- a/kern/kdebug.c
-+++ b/kern/kdebug.c
-@@ -140,9 +140,11 @@ find_function(const char *const fname) {
-      * in assembly. */
- 
-     // LAB 3: Your code here:
-+    #ifdef CONFIG_KSPACE
- 
--    //if (!strcmp("sys_yield", fname)) return (uintptr_t)sys_yield;
--    //if (!strcmp("sys_exit", fname)) return (uintptr_t)sys_exit;
-+    if (!strcmp("sys_yield", fname)) return (uintptr_t)sys_yield;
-+    if (!strcmp("sys_exit", fname)) return (uintptr_t)sys_exit;
-+    #endif
- 
-     struct Dwarf_Addrs addrs;
-     load_kernel_dwarf_info(&addrs);
-diff --git a/kern/pmap.c b/kern/pmap.c
-index 5653866..4d1e103 100644
---- a/kern/pmap.c
-+++ b/kern/pmap.c
-@@ -1931,7 +1931,28 @@ static uintptr_t user_mem_check_addr;
- int
- user_mem_check(struct Env *env, const void *va, size_t len, int perm) {
-     // LAB 8: Your code here
--    return -E_FAULT;
-+    //perm = perm | PTE_P;
-+
-+    const void *end = va + len;
-+    const void *va_b = va;
-+    va = (void*) ROUNDDOWN(va, PAGE_SIZE);
-+    struct Page *root = env->address_space.root;
-+    while (va < end)
-+    {
-+        struct Page* smallest_page = page_lookup_virtual(root, (uintptr_t)va, 0, 0);
-+        if (!smallest_page->phy || (smallest_page->state & perm) != perm ){
-+          user_mem_check_addr = (uintptr_t) MAX(va,va_b);
-+          return -E_FAULT;
-+        }
-+    va += PAGE_SIZE;
-+    }
-+
-+    if ((uintptr_t) end > MAX_USER_READABLE){
-+        user_mem_check_addr = MAX(MAX_USER_READABLE, (uintptr_t)va_b);
-+        return -E_FAULT;
-+    }
-+
-+  return 0;
- }
- 
- void
-diff --git a/kern/trap.c b/kern/trap.c
-index bfa41f5..3256133 100644
---- a/kern/trap.c
-+++ b/kern/trap.c
-@@ -197,6 +197,15 @@ trap_init_percpu(void) {
-     lidt(&idt_pd);
- }
- 
-+void
-+clock_idt_init(void) {
-+  extern void (*clock_thdlr)(void);
-+  // init idt structure
-+  idt[IRQ_OFFSET + IRQ_TIMER] = GATE(0, GD_KT, (uintptr_t)(&clock_thdlr), 0);
-+  idt[IRQ_OFFSET + IRQ_CLOCK] = GATE(0, GD_KT, (uintptr_t)(&clock_thdlr), 0);
-+  lidt(&idt_pd);
-+}
-+
- void
- print_trapframe(struct Trapframe *tf) {
-     cprintf("TRAP frame at %p\n", tf);
-diff --git a/kern/trapentry.S b/kern/trapentry.S
-index a1dd84b..587ce58 100644
---- a/kern/trapentry.S
-+++ b/kern/trapentry.S
-@@ -78,7 +78,7 @@ _alltraps:
-   jmp .
- 
- TRAPHANDLER_NOEC(clock_thdlr, IRQ_OFFSET + IRQ_CLOCK)
--// LAB 8 code
-+
- TRAPHANDLER_NOEC(divide_thdlr, T_DIVIDE)
- TRAPHANDLER_NOEC(debug_thdlr, T_DEBUG)
- TRAPHANDLER_NOEC(nmi_thdlr, T_NMI)
